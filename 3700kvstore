#!/usr/bin/env python

import sys, socket, select, time, json, random, math

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# number of replicas that constitutes a quorom
quorum_size = int(math.ceil((len(replica_ids) + 1) / 2.0))

# A State is one of:
FOLLOWER = "FOLLOWER"
LEADER = "LEADER"
CANDIDATE = "CANDIDATE"

# Current state of the replica
my_state = FOLLOWER

# ID number of the leader
leader_id = 'FFFF'

# ID of replica voted as leader in this term - only for outstanding elections,
# will be None otherwise
voted_for = None

# current term number
term = 0

# count of votes received
vote_count = 0

# Random timeout before electing self as leader, in seconds
leader_timeout = None

def pick_random_timeout():
    global leader_timeout
    leader_timeout = random.randint(150, 300) / 1000.0

pick_random_timeout()

# key-value store for the leader
store = {}
# log entries; contains (command for machine, term, client id)
# also, first index is apparently supposed to be 1
# command for mahine: ['GET', 123]
log = [[[1], 1, 1]]
log = [{
    "command": {
        "type": 1,
        "key": 1,
        "val": 1,
    },
    "term": 1,
    "client_id": 1
}]
# index in the log of the most recent commit
commit_index = 0
# index of highest log entry applied to machine
last_applied = 0
# for each server, index of the next log entry that you need to send
next_index = {}
# for each server, index of highest log entry known to be replicated
match_index = {}

# Message Types:
GET = 'get'
PUT = 'put'
REQUEST_VOTE = 'request_vote'
SEND_VOTE = 'send_vote'
APPEND_ENTRIES = 'append_entries'
FAIL = 'fail'
OK = 'ok'
REDIRECT = 'redirect'

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

# last time a message from the leader was received
last_leader_msg = time.clock()


def send(msg):
    sock.send(json.dumps(msg))


def get(msg):
    get_source = msg['src']
    get_mid = msg.get('MID', None)
    reply = {'src': my_id, 'dst': get_source, 'leader': leader_id}
    if get_mid:
        reply['MID'] = get_mid
    if my_state == LEADER:
        key = msg['key']
        val = store.get(key, None)
        if val:
            reply['type'] = OK
            reply['value'] = val
        else:
            reply['type'] = FAIL

        command = {
            "type": GET,
            "key": key,
        }
        entry = {
            "command": command,
            "term": term,
            "client_id", get_source,
        }
        log.append(entry)
        print log
    else:
        reply['type'] = REDIRECT
    send(reply)

def put(msg):
    global log

    put_source = msg['src']
    put_mid = msg.get('MID', None)
    reply = {'src': my_id, 'dst': put_source, 'leader': leader_id}
    if put_mid:
        reply['MID'] = put_mid
    if my_state == LEADER:
        key = msg['key']
        val = msg['value']
        store[key] = val
        reply['type'] = OK

        command = {
            "type": PUT,
            "key": key,
            "val": val,
        }
        entry = {
            "command": command,
            "term": term,
            "client_id", put_source,
        }
        log.append(entry)
        print log
    else:
        reply['type'] = REDIRECT
    send(reply)


def send_vote(msg):
    global voted_for, term, my_state, last_leader_msg

    # if recv term < my term, false
    # if i voted for someone already, false
    # else update my term and vote for them

    received_term = msg['term']
    candidate_id = msg['src']

    reply = {'src': my_id, 'dst': candidate_id, 'type':SEND_VOTE }

    if received_term < term or (received_term == term and voted_for is not None):
        reply['leader'] = leader_id
        reply['granted'] = False
        reply['term'] = term
        send(reply)
    else:
        # must downgrade LEADER -> FOLLOWER if we find out about an election
        my_state = FOLLOWER
        voted_for = candidate_id

        term = received_term
        # must not timeout before election has time to finish
        last_leader_msg = time.clock()
        print my_id, 'has voted for', candidate_id, ' in term ', term, time.clock()
        reply['leader'] = leader_id
        reply['granted'] = True
        reply['term'] = term
        send(reply)


def accept_vote(msg):
    global vote_count, my_state, leader_id
    granted = msg['granted']

    if granted:
        vote_count += 1
        print my_id, 'received vote from', msg['src'], vote_count, ' in term ', term
    if vote_count >= quorum_size:
        print my_id, 'has won the vote - term: ', term
        my_state = LEADER
        leader_id = my_id
        election_over_msg = {'src': my_id, 'dst': 'FFFF', 'leader': leader_id, 'term': term, 'type': APPEND_ENTRIES }
        send(election_over_msg)


def append_entries(msg):
    global leader_id, last_leader_msg, leader_timeout, voted_for, term, my_state
    msg_leader = msg['leader']
    recv_term = msg['term']

    if recv_term >= term:
        term = recv_term
        my_state = FOLLOWER
        last_leader_msg = time.clock()
        # later update log here

        if msg_leader != leader_id:
            print my_id, 'has accepted leader:', msg_leader, 'term: ', term, time.clock()
            leader_id = msg_leader
            pick_random_timeout()
            voted_for = None


def conduct_election():
    global leader_id, my_state, vote_count, term, voted_for
    print my_id, 'has started an election term: ', term + 1, time.clock()

    my_state = CANDIDATE
    term += 1
    vote_count = 1
    voted_for = my_id
    pick_random_timeout()
    request_vote_msg = { 'src': my_id, 'dst': 'FFFF', 'leader': leader_id, 'term': term, 'type': REQUEST_VOTE }
    send(request_vote_msg)


while True:
    ready = select.select([sock], [], [], 0.1)[0]

    if sock in ready:
        msg_raw = sock.recv(32768)

        if len(msg_raw) == 0: continue
        msg = json.loads(msg_raw)

        if msg['type'] == GET:
            get(msg)
        if msg['type'] == PUT:
            put(msg)
        if msg['type'] == REQUEST_VOTE:
            send_vote(msg)
        if msg['type'] == SEND_VOTE and my_state == CANDIDATE:
            accept_vote(msg)
        if msg['type'] == APPEND_ENTRIES:
            append_entries(msg)


    clock = time.clock()
    if clock - last_leader_msg > leader_timeout:
        # trigger leader elections if a follower
        if my_state == FOLLOWER and voted_for is None:
            conduct_election()
    if my_state == LEADER and clock - last_leader_msg > 0.050:
        # send mass heartbeat
        heartbeat_msg = {'src': my_id, 'dst': 'FFFF', 'leader': leader_id, 'term': term, 'type': APPEND_ENTRIES }
        send(heartbeat_msg)
        last_leader_msg = clock
